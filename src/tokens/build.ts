/**
 * Token build script.
 *
 * Reads Figma design-token JSON files from `design-tokens/` and generates
 * typed TypeScript theme objects in `src/tokens/generated/`.
 *
 * Usage:  npx ts-node src/tokens/build.ts
 *
 * The generated files are gitignored – run this before Storybook or library
 * builds.
 */

import * as fs from 'fs';
import * as path from 'path';

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/**
 * Recursively resolve a token `$value`.
 *
 * - String references like `{Primitive.Colour.Slate-900}` are followed
 *   through the full token tree until a concrete value is reached.
 * - Figma color objects (with a `hex` property) are collapsed to hex strings.
 * - Numbers and plain strings are returned as-is.
 */
function resolveValue(root: Record<string, unknown>, value: unknown): string | number {
  // Reference string – follow the alias chain
  if (typeof value === 'string' && value.startsWith('{') && value.endsWith('}')) {
    const refPath = value.slice(1, -1); // strip { }
    const parts = refPath.split('.');

    let cursor: unknown = root;
    for (const part of parts) {
      if (cursor && typeof cursor === 'object' && part in (cursor as Record<string, unknown>)) {
        cursor = (cursor as Record<string, unknown>)[part];
      } else {
        throw new Error(`Cannot resolve token reference: ${value} (failed at "${part}")`);
      }
    }

    // `cursor` is now the token node – recurse on its $value
    const node = cursor as Record<string, unknown>;
    if ('$value' in node) {
      return resolveValue(root, node.$value);
    }
    throw new Error(`Token at "${refPath}" has no $value`);
  }

  // Figma color object – extract hex
  if (typeof value === 'object' && value !== null && 'hex' in (value as Record<string, unknown>)) {
    return (value as Record<string, unknown>).hex as string;
  }

  // Direct number or string
  if (typeof value === 'number' || typeof value === 'string') {
    return value;
  }

  throw new Error(`Unexpected token value type: ${JSON.stringify(value)}`);
}

/**
 * Shorthand: navigate to a token by its dot-separated path and resolve.
 */
function resolve(root: Record<string, unknown>, tokenPath: string): string | number {
  const parts = tokenPath.split('.');
  let cursor: unknown = root;
  for (const part of parts) {
    if (cursor && typeof cursor === 'object' && part in (cursor as Record<string, unknown>)) {
      cursor = (cursor as Record<string, unknown>)[part];
    } else {
      throw new Error(`Token path not found: ${tokenPath} (failed at "${part}")`);
    }
  }
  const node = cursor as Record<string, unknown>;
  if ('$value' in node) {
    return resolveValue(root, node.$value);
  }
  throw new Error(`Token at "${tokenPath}" has no $value`);
}

// ---------------------------------------------------------------------------
// Theme builder
// ---------------------------------------------------------------------------

interface ThemeConfig {
  file: string;
  name: 'white-label' | 'consumer' | 'corporate' | 'luxury';
  exportName: string;
}

const THEMES: ThemeConfig[] = [
  { file: 'White label.tokens.json', name: 'white-label', exportName: 'whiteLabel' },
  { file: 'Consumer.tokens.json', name: 'consumer', exportName: 'consumer' },
  { file: 'Corporate.tokens.json', name: 'corporate', exportName: 'corporate' },
  { file: 'Luxury.tokens.json', name: 'luxury', exportName: 'luxury' },
];

function buildThemeSource(config: ThemeConfig, tokens: Record<string, unknown>): string {
  const r = (p: string) => resolve(tokens, p);
  const s = (p: string) => JSON.stringify(r(p)); // string-safe for codegen

  return `// Auto-generated by src/tokens/build.ts – DO NOT EDIT
import type { AtlasTheme } from '../../theme/types';

export const ${config.exportName}: AtlasTheme = {
  name: '${config.name}',

  semantic: {
    color: {
      surface: ${s('Semantic.Colour.Surface')},
      onSurface: ${s('Semantic.Colour.On-Surface')},
      onSurfaceMuted: ${s('Semantic.Colour.On-Surface-Muted')},
      surfaceContainer: ${s('Semantic.Colour.Surface-Container')},

      primary: ${s('Semantic.Colour.Primary')},
      onPrimary: ${s('Semantic.Colour.On-Primary')},
      primaryHover: ${s('Semantic.Colour.Primary-Hover')},
      primaryPressed: ${s('Semantic.Colour.Primary-Pressed')},

      secondary: ${s('Semantic.Colour.Secondary')},
      onSecondary: ${s('Semantic.Colour.On-Secondary')},

      success: ${s('Semantic.Colour.Success')},
      onSuccess: ${s('Semantic.Colour.On-Success')},
      error: ${s('Semantic.Colour.Error')},
      onError: ${s('Semantic.Colour.On-Error')},
      warning: ${s('Semantic.Colour.Warning')},
      onWarning: ${s('Semantic.Colour.On-Warning')},

      border: ${s('Semantic.Colour.Border')},
      borderSubtle: ${s('Semantic.Colour.Border-Subtle')},

      disabledContainer: ${s('Semantic.Colour.Disabled-Container')},
      onDisabled: ${s('Semantic.Colour.On-Disabled')},

      primaryContainer: ${s('Semantic.Colour.Primary-Container')},
      onPrimaryContainer: ${s('Semantic.Colour.On-Primary-Container')},
      secondaryContainer: ${s('Semantic.Colour.Secondary-Container')},
      onSecondaryContainer: ${s('Semantic.Colour.On-Secondary-Container')},
      errorContainer: ${s('Semantic.Colour.Error-Container')},
      onErrorContainer: ${s('Semantic.Colour.On-Error-Container')},
      successContainer: ${s('Semantic.Colour.Success-Container')},
      onSuccessContainer: ${s('Semantic.Colour.On-Success-Container')},
      warningContainer: ${s('Semantic.Colour.Warning-Container')},
      onWarningContainer: ${s('Semantic.Colour.On-Warning-Container')},
    },

    fontFamily: {
      brand: ${s('Semantic.Font family.Font-Brand')},
      interface: ${s('Semantic.Font family.Font-Interface')},
      data: ${s('Semantic.Font family.Font-Data')},
    },

    fontSize: {
      display: ${r('Semantic.Text size.Text-size-display')},
      h1: ${r('Semantic.Text size.Text-size-h1')},
      h2: ${r('Semantic.Text size.Text-size-h2')},
      h3: ${r('Semantic.Text size.Text-size-h3')},
      body: ${r('Semantic.Text size.Text-size-body')},
      small: ${r('Semantic.Text size.Text-size-small')},
      button: ${r('Semantic.Text size.Text-size-button')},
    },

    fontWeight: {
      heading: ${r('Semantic.Font weight.Weight-heading')},
      body: ${r('Semantic.Font weight.Weight-body')},
      button: ${r('Semantic.Font weight.Weight-button')},
    },

    lineHeight: {
      heading: ${r('Semantic.Line height.Line-Height-heading')},
      body: ${r('Semantic.Line height.Line-Height-body')},
      uiLabel: ${r('Semantic.Line height.Line-Height-UI-label')},
    },

    letterSpacing: {
      heading: ${r('Semantic.Letter spacing.Tracking-heading')},
      body: ${r('Semantic.Letter spacing.Tracking-body')},
      label: ${r('Semantic.Letter spacing.Tracking-label')},
    },

    paragraphSpacing: {
      body: ${r('Semantic.Paragraph spacing.Para-body')},
      editorial: ${r('Semantic.Paragraph spacing.Para-editorial')},
    },

    paragraphIndent: {
      editorial: ${r('Semantic.Paragraph indent.Indent-editorial')},
    },

    borderRadius: {
      small: ${r('Semantic.Border radius.Radius-Small')},
      medium: ${r('Semantic.Border radius.Radius-Medium')},
      large: ${r('Semantic.Border radius.Radius-Large')},
    },
  },

  component: {
    button: {
      paddingHorizontal: ${r('Component.Button.Padding-Horizontal')},
      paddingVertical: ${r('Component.Button.Padding-Vertical')},
      gap: ${r('Component.Button.Gap')},
      cornerRadius: ${r('Component.Button.Corner-Radius')},
      borderWidth: ${r('Component.Button.Border-Width')},
      textSize: ${r('Component.Button.Text-Size')},
      fontWeight: ${r('Component.Button.Font-Weight')},
      lineHeight: ${r('Component.Button.Line-Height')},
      fontFamily: ${s('Component.Button.Font-Family')},

      filled: {
        background: ${s('Component.Button.Filled.Background')},
        content: ${s('Component.Button.Filled.Content')},
      },
      outline: {
        background: ${s('Component.Button.Outline.Background')},
        border: ${s('Component.Button.Outline.Border')},
        content: ${s('Component.Button.Outline.Content')},
      },
      text: {
        background: ${s('Component.Button.Text.Background')},
        content: ${s('Component.Button.Text.Content')},
      },
      state: {
        hoverBackground: ${s('Component.Button.State.Hover-Background')},
        pressedBackground: ${s('Component.Button.State.Pressed-Background')},
        disabledBackground: ${s('Component.Button.State.Disabled-Background')},
        disabledContent: ${s('Component.Button.State.Disabled-Content')},
      },
    },

    card: {
      padding: ${r('Component.Card.Padding')},
      gap: ${r('Component.Card.Gap')},
      background: ${s('Component.Card.Background')},
      stroke: ${s('Component.Card.Stroke')},
      strokeWidth: ${r('Component.Card.Stroke-Width')},
      cornerRadius: ${r('Component.Card.Corner-Radius')},
      elevation: ${r('Component.Card.Elevation')},
      headingSize: ${r('Component.Card.Heading-Size')},
      headingWeight: ${r('Component.Card.Heading-Weight')},
      headingFontFamily: ${s('Component.Card.Heading-Font-Family')},
      bodySize: ${r('Component.Card.Body-Size')},
      bodyWeight: ${r('Component.Card.Body-Weight')},
      bodyFontFamily: ${s('Component.Card.Body-Font-Family')},
    },
  },
};
`;
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

function main(): void {
  const rootDir = path.resolve(__dirname, '..', '..');
  const tokensDir = path.join(rootDir, 'design-tokens');
  const outDir = path.join(rootDir, 'src', 'tokens', 'generated');

  // Ensure output directory exists
  fs.mkdirSync(outDir, { recursive: true });

  const exports: string[] = [];

  for (const theme of THEMES) {
    const filePath = path.join(tokensDir, theme.file);
    const raw = fs.readFileSync(filePath, 'utf-8');
    const tokens = JSON.parse(raw);

    const source = buildThemeSource(theme, tokens);
    const outFile = path.join(outDir, `${theme.name}.ts`);
    fs.writeFileSync(outFile, source, 'utf-8');

    exports.push(`export { ${theme.exportName} } from './${theme.name}';`);
    console.log(`  ✓ ${theme.name} → ${path.relative(rootDir, outFile)}`);
  }

  // Write barrel index
  const indexSource = [
    '// Auto-generated by src/tokens/build.ts – DO NOT EDIT',
    "export type { AtlasTheme, ThemeName } from '../../theme/types';",
    '',
    ...exports,
    '',
  ].join('\n');

  fs.writeFileSync(path.join(outDir, 'index.ts'), indexSource, 'utf-8');
  console.log('  ✓ index.ts');
  console.log('\nToken build complete.');
}

main();
